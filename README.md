# Сервер многопользовательской игры

## Описание

Это серверное приложение для многопользовательской онлайн-игры, разработанное на C++ с использованием библиотек Boost и pqxx. Игроки, представленные в игре персонажами (собаками), могут присоединяться к игровым сессиям, перемещаться по карте, собирать трофеи (лут) и сдавать их в офисы для получения очков. Сервер обеспечивает асинхронную обработку запросов, управление игровым состоянием, генерацию трофеев и хранение данных игроков, предоставляя надежную платформу для игрового процесса в реальном времени.

**Технологический стек:**

- **C++** (стандарт C++20) для высокопроизводительной серверной логики.
- **Boost библиотеки**:
  - `Boost.Asio`: асинхронная обработка сетевых операций и таймеров.
  - `Boost.Beast`: обработка HTTP-запросов и ответов.
  - `Boost.JSON`: парсинг и генерация JSON для конфигурации и API.
  - `Boost.Serialization`: сериализация игрового состояния.
  - `Boost.UUID`: генерация уникальных идентификаторов.
  - `Boost.Log`: логирование событий в формате JSON.
- **PostgreSQL** с библиотекой **pqxx** для хранения данных об игроках.
- **Стандартная библиотека C++ (STL)**: контейнеры (`std::unordered_map`, `std::vector`), умные указатели, алгоритмы.
- **CMake**: для сборки проекта.
- **Conan**: менеджер зависимостей для управления библиотеками C++.
- **Docker**: контейнеризация приложения для упрощения развертывания и обеспечения консистентности окружения.
- **std::jthread**: для управления рабочими потоками.

**Цель проекта:** Создание масштабируемого серверного приложения, демонстрирующего навыки работы с асинхронным программированием, базами данных и сложной игровой логикой. Проект решает задачу обеспечения стабильного многопользовательского игрового процесса с гибкой конфигурацией и отказоустойчивостью, а использование Docker упрощает развертывание и тестирование.

## Возможности

- **Асинхронный HTTP-сервер**: Обработка запросов для присоединения к игре, управления действиями игроков, получения состояния игры и карт.
- **Игровая механика**: Перемещение игроков по дорогам, сбор трофеев с учетом коллизий, управление инвентарем и начисление очков.
- **Сохранение состояния**: Периодическое сохранение и восстановление игрового состояния с использованием сериализации Boost и PostgreSQL.
- **Генерация трофеев**: Динамическое создание трофеев на основе заданной вероятности и времени.
- **Конфигурация через JSON**: Загрузка игровых карт, параметров скорости игроков и вместимости инвентаря из JSON-файлов.
- **Хранение данных игроков**: Сохранение результатов завершивших игру игроков в базе данных PostgreSQL.

## Системные требования

- **Компилятор**: C++ с поддержкой C++17 (GCC 7+, Clang 5+, MSVC 2017+).
- **Библиотеки**: Boost (версия 1.75 или выше), pqxx.
- **База данных**: PostgreSQL (версия 12 или выше).
- **Система сборки**: CMake (версия 3.10 или выше).
- **Контейнеризация**: Docker (для контейнеризированного развертывания).
- **Операционная система**: Linux, macOS или Windows с поддержкой указанных инструментов (рекомендуется Linux для Docker).

## Установка и развертывание

1. **Установка зависимостей**:
   - Установите компилятор C++ с поддержкой C++17 ([GCC](https://gcc.gnu.org/), [Clang](https://clang.llvm.org/), или [MSVC](https://visualstudio.microsoft.com/)).
   - Установите библиотеки Boost ([Boost](https://www.boost.org/)).
   - Установите PostgreSQL ([PostgreSQL](https://www.postgresql.org/)) и настройте базу данных.
   - Установите библиотеку pqxx ([pqxx](https://github.com/jtv/libpqxx)).
   - Установите CMake ([CMake](https://cmake.org/)) и Conan (`pip3 install conan==1.*`).

2. **Настройка базы данных**:
   - Создайте базу данных PostgreSQL и пользователя с соответствующими правами.
   - Укажите строку подключения в конфигурации приложения (например, `postgresql://user:password@localhost:5432/dbname`).
   - Метод `InitializeDatabase` в `DbHandler` автоматически создает таблицу `retired_players` и индекс для хранения данных игроков.

3. **Сборка проекта**:
   ```bash
   mkdir build
   cd build
   cmake ..
   make
   ```

4. **Подготовка конфигурации**:
   - Создайте JSON-файл с настройками игры (карты, параметры игроков, такие как скорость и вместимость инвентаря).
   - Настройте директорию для статических файлов (например, HTML, CSS для клиентского интерфейса).

5. **Запуск приложения**:
   ```bash
   ./game_server [опции]
   ```

   **Ключи командной строки**:
   | **Ключ**                     | **Описание**                                                                 | **Пример**                              |
   |------------------------------|------------------------------------------------------------------------------|-----------------------------------------|
   | `--config-file <path>`       | Путь к JSON-файлу с конфигурацией игры (карты, параметры).                   | `--config-file config/game.json`        |
   | `--www-root <path>`          | Директория со статическими файлами для клиентского интерфейса (HTML, CSS).   | `--www-root static/`                    |
   | `--tick-period <milliseconds>` | Период игрового цикла в миллисекундах (для автоматического обновления состояния). | `--tick-period 100`                     |
   | `--randomize-spawn-points`   | Включает случайные точки появления для игроков на карте.                     | `--randomize-spawn-points`              |
   | `--state-file <path>`        | Путь к файлу для сохранения игрового состояния (сериализация).               | `--state-file save/state.dat`           |
   | `--save-state-period <milliseconds>` | Период сохранения игрового состояния в миллисекундах.                 | `--save-state-period 60000`             |

## Технические особенности

### Используемые инструменты, алгоритмы и паттерны

- **Алгоритмы**:
  - **Обнаружение коллизий**: Геометрический алгоритм в `collision_detector` для определения сбора трофеев, использующий проекции и радиусы объектов.
  - **Генерация трофеев**: Вероятностный алгоритм в `loot_generator` с настраиваемыми параметрами вероятности и интервала.
  - **Перемещение игроков**: Хэш-таблица `RoadLookup` в `model.cpp` для быстрой проверки позиций на дорогах с шагом 0.5.

- **Паттерны проектирования**:
  - **Асинхронный цикл событий**: `Boost.Asio` для неблокирующей обработки запросов.
  - **Strand-паттерн**: `boost::asio::strand` для сериализации асинхронных операций, исключая состояния гонки.
  - **Пул соединений**: Реализация в `db_connection_pool.h` для эффективного управления подключениями к PostgreSQL.
  - **Управление временем жизни объектов**: `std::enable_shared_from_this` в классах `Session`, `Listener`, `Ticker` для безопасного управления `shared_ptr` в асинхронных операциях.
  - **Сериализация**: `Boost.Serialization` для сохранения и восстановления игрового состояния.
  - **Модульная архитектура**: Разделение логики на сценарии (`JoinGameScenario`, `ActionGameScenario`) для упрощения тестирования и расширения.

### Дополнительные особенности

- **Потокобезопасность**: Использование `boost::asio::strand` и пула соединений для безопасной работы в многопоточной среде.
- **Отказоустойчивость**: Сохранение состояния в файл (`Boost.Serialization`) и базу данных (PostgreSQL) для восстановления после сбоев.
- **Гибкость конфигурации**: Поддержка настройки параметров через JSON-файлы и командную строку.

## Планы по доработке

| **Задача**                              | **Решение**                                                                 | **Ожидаемый результат**                              |
|-----------------------------------------|-----------------------------------------------------------------------------|-----------------------------------------------------|
| Оптимизация базы данных                 | Внедрение кэширования игровых данных с использованием Redis.                 | Уменьшение нагрузки на PostgreSQL и ускорение запросов. |
| Аутентификация игроков                  | Интеграция OAuth 2.0 для безопасного входа в игру.                          | Повышение безопасности и защиты данных игроков.     |
| Расширенное логирование                 | Внедрение Prometheus для мониторинга производительности и логирования.       | Улучшение диагностики и анализа производительности.  |
| Оптимизация RoadLookup                  | Замена хэш-таблицы на пространственную структуру данных (например, R-дерево).| Ускорение проверки позиций игроков на больших картах.|
